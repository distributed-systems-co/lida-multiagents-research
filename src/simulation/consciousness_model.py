"""
Consciousness Simulation Module

Advanced consciousness modeling including:
- Integrated Information Theory (IIT) - Phi calculation
- Global Workspace Theory (GWT) - Broadcast and binding
- Higher-Order Theories - Meta-awareness
- Attention and Access Consciousness
- Phenomenal Binding
- Self-Model and Introspection
- Qualia Representation
- Stream of Consciousness

Based on:
- Tononi's Integrated Information Theory
- Baars' Global Workspace Theory
- Higher-Order Thought Theories
- Attention Schema Theory
- Predictive Processing
"""

import random
import math
from datetime import datetime
from typing import Dict, List, Optional, Any, Set, Tuple, Callable
from dataclasses import dataclass, field
from enum import Enum
from collections import defaultdict
import heapq


# ============================================================================
# QUALIA AND PHENOMENAL EXPERIENCE
# ============================================================================

class QualiaType(Enum):
    """Types of phenomenal experience"""
    SENSORY = "sensory"  # Perceptual qualia
    EMOTIONAL = "emotional"  # Affective qualia
    COGNITIVE = "cognitive"  # Thought-feel
    VOLITIONAL = "volitional"  # Agency feel
    TEMPORAL = "temporal"  # Time experience
    SPATIAL = "spatial"  # Space experience
    SELF = "self"  # Self-awareness feel


@dataclass
class Quale:
    """A single quale (unit of subjective experience)"""
    id: str
    quale_type: QualiaType
    content: Dict[str, Any]  # The 'what it is like'
    intensity: float = 0.5
    valence: float = 0.0  # -1 to 1 (unpleasant to pleasant)
    arousal: float = 0.5
    timestamp: datetime = field(default_factory=datetime.now)

    # Binding to other qualia
    bound_to: Set[str] = field(default_factory=set)

    def bind(self, other_id: str):
        """Bind this quale to another"""
        self.bound_to.add(other_id)


@dataclass
class PhenomenalField:
    """The complete field of conscious experience at a moment"""
    qualia: Dict[str, Quale] = field(default_factory=dict)
    focus: Optional[str] = None  # Currently attended quale
    background: Set[str] = field(default_factory=set)  # Peripheral awareness
    unity: float = 0.5  # How unified the experience is
    timestamp: datetime = field(default_factory=datetime.now)

    def add_quale(self, quale: Quale, attended: bool = False):
        """Add a quale to the field"""
        self.qualia[quale.id] = quale
        if attended:
            self.focus = quale.id
        else:
            self.background.add(quale.id)

    def get_total_intensity(self) -> float:
        """Get total intensity of experience"""
        return sum(q.intensity for q in self.qualia.values())

    def get_emotional_valence(self) -> float:
        """Get average emotional valence"""
        emotional = [
            q.valence for q in self.qualia.values()
            if q.quale_type == QualiaType.EMOTIONAL
        ]
        return sum(emotional) / len(emotional) if emotional else 0.0


# ============================================================================
# INTEGRATED INFORMATION THEORY (IIT)
# ============================================================================

@dataclass
class InformationState:
    """State of an information element"""
    id: str
    state: int  # Binary state (0 or 1)
    connections: Dict[str, float] = field(default_factory=dict)  # To other elements


class IntegratedInformationCalculator:
    """
    Calculates integrated information (Phi) based on IIT.
    Simplified implementation for simulation purposes.
    """

    def __init__(self):
        self.elements: Dict[str, InformationState] = {}
        self.transition_matrix: Dict[Tuple[str, str], float] = {}

    def add_element(self, element: InformationState):
        """Add an information element"""
        self.elements[element.id] = element

    def set_transition(self, from_state: Tuple, to_state: Tuple, probability: float):
        """Set transition probability between states"""
        self.transition_matrix[(from_state, to_state)] = probability

    def calculate_phi(self, partition: Tuple[Set[str], Set[str]] = None) -> float:
        """
        Calculate integrated information (Phi).
        Phi measures how much information is generated by the whole above parts.
        """
        if len(self.elements) < 2:
            return 0.0

        # Get current state
        current_state = tuple(e.state for e in self.elements.values())

        # Calculate whole system information
        whole_info = self._calculate_mutual_information(set(self.elements.keys()))

        # Find minimum information partition (MIP)
        if partition is None:
            partition = self._find_mip()

        # Calculate partitioned information
        if partition:
            part1_info = self._calculate_mutual_information(partition[0])
            part2_info = self._calculate_mutual_information(partition[1])
            partitioned_info = part1_info + part2_info
        else:
            partitioned_info = 0

        # Phi = whole - partitioned
        phi = max(0, whole_info - partitioned_info)

        return phi

    def _calculate_mutual_information(self, elements: Set[str]) -> float:
        """Calculate mutual information within a set of elements"""
        if len(elements) < 2:
            return 0.0

        # Simplified: based on connection strengths
        total_info = 0.0
        element_list = list(elements)

        for i, e1_id in enumerate(element_list):
            e1 = self.elements.get(e1_id)
            if not e1:
                continue

            for e2_id in element_list[i+1:]:
                if e2_id in e1.connections:
                    # Connection strength approximates mutual information
                    total_info += e1.connections[e2_id]

        return total_info

    def _find_mip(self) -> Optional[Tuple[Set[str], Set[str]]]:
        """Find minimum information partition"""
        if len(self.elements) < 2:
            return None

        all_elements = set(self.elements.keys())
        min_cut_value = float('inf')
        min_partition = None

        # Try all possible bipartitions
        element_list = list(all_elements)
        n = len(element_list)

        for i in range(1, 2**(n-1)):
            part1 = set()
            part2 = set()

            for j in range(n):
                if (i >> j) & 1:
                    part1.add(element_list[j])
                else:
                    part2.add(element_list[j])

            if not part1 or not part2:
                continue

            # Calculate cut value (information lost)
            cut_value = self._calculate_cut_value(part1, part2)

            if cut_value < min_cut_value:
                min_cut_value = cut_value
                min_partition = (part1, part2)

        return min_partition

    def _calculate_cut_value(self, part1: Set[str], part2: Set[str]) -> float:
        """Calculate information cut between two partitions"""
        cut_value = 0.0

        for e1_id in part1:
            e1 = self.elements.get(e1_id)
            if e1:
                for e2_id in part2:
                    if e2_id in e1.connections:
                        cut_value += e1.connections[e2_id]

        return cut_value

    def get_consciousness_level(self) -> str:
        """Get qualitative consciousness level based on Phi"""
        phi = self.calculate_phi()

        if phi < 0.1:
            return "unconscious"
        elif phi < 0.3:
            return "minimally_conscious"
        elif phi < 0.5:
            return "drowsy"
        elif phi < 0.7:
            return "aware"
        elif phi < 0.9:
            return "highly_conscious"
        else:
            return "peak_consciousness"


# ============================================================================
# GLOBAL WORKSPACE
# ============================================================================

class WorkspaceContentType(Enum):
    """Types of content in global workspace"""
    PERCEPT = "percept"
    THOUGHT = "thought"
    MEMORY = "memory"
    INTENTION = "intention"
    EMOTION = "emotion"
    MOTOR_PLAN = "motor_plan"
    META_COGNITION = "meta_cognition"


@dataclass
class WorkspaceContent:
    """Content competing for global workspace"""
    id: str
    content_type: WorkspaceContentType
    data: Dict[str, Any]
    activation: float = 0.0
    salience: float = 0.5
    relevance: float = 0.5
    timestamp: datetime = field(default_factory=datetime.now)
    coalition: Set[str] = field(default_factory=set)  # Other contents in coalition

    def boost(self, amount: float):
        """Boost activation"""
        self.activation = min(1.0, self.activation + amount)

    def decay(self, rate: float = 0.1):
        """Decay activation"""
        self.activation *= (1 - rate)


class GlobalWorkspace:
    """
    Implementation of Global Workspace Theory.
    Contents compete for broadcast to all modules.
    """

    def __init__(self, broadcast_threshold: float = 0.7):
        self.contents: Dict[str, WorkspaceContent] = {}
        self.current_broadcast: Optional[str] = None
        self.broadcast_history: List[str] = []
        self.broadcast_threshold = broadcast_threshold

        # Specialized modules that receive broadcasts
        self.modules: Dict[str, Callable] = {}

        # Attention
        self.attention_focus: Optional[str] = None
        self.attention_strength: float = 0.5

    def add_content(self, content: WorkspaceContent):
        """Add content to workspace"""
        self.contents[content.id] = content

    def register_module(self, name: str, callback: Callable):
        """Register a module to receive broadcasts"""
        self.modules[name] = callback

    def attend(self, content_id: str, strength: float = 0.5):
        """Direct attention to content"""
        if content_id in self.contents:
            self.attention_focus = content_id
            self.attention_strength = strength
            self.contents[content_id].boost(strength * 0.3)

    def competition_cycle(self) -> Optional[str]:
        """Run one cycle of competition for workspace"""
        # Decay all activations
        for content in self.contents.values():
            content.decay(0.1)

        # Boost attended content
        if self.attention_focus and self.attention_focus in self.contents:
            self.contents[self.attention_focus].boost(self.attention_strength * 0.2)

        # Find winner
        if not self.contents:
            return None

        # Calculate effective activation (base + salience + relevance)
        activations = {}
        for cid, content in self.contents.items():
            effective = (
                content.activation * 0.5 +
                content.salience * 0.3 +
                content.relevance * 0.2
            )
            activations[cid] = effective

        winner_id = max(activations, key=activations.get)
        winner_activation = activations[winner_id]

        if winner_activation >= self.broadcast_threshold:
            self._broadcast(winner_id)
            return winner_id

        return None

    def _broadcast(self, content_id: str):
        """Broadcast winning content to all modules"""
        self.current_broadcast = content_id
        self.broadcast_history.append(content_id)

        if len(self.broadcast_history) > 100:
            self.broadcast_history.pop(0)

        content = self.contents[content_id]

        # Notify all modules
        for module_name, callback in self.modules.items():
            try:
                callback(content)
            except Exception:
                pass  # Module failed to process

    def form_coalition(self, content_ids: List[str]) -> str:
        """Form a coalition of related contents"""
        if not content_ids:
            return ""

        coalition_id = f"coalition_{len(self.contents)}"

        # Merge into coalition
        combined_data = {}
        combined_activation = 0
        combined_salience = 0

        for cid in content_ids:
            if cid in self.contents:
                content = self.contents[cid]
                combined_data[cid] = content.data
                combined_activation += content.activation
                combined_salience = max(combined_salience, content.salience)

        coalition = WorkspaceContent(
            id=coalition_id,
            content_type=WorkspaceContentType.THOUGHT,
            data=combined_data,
            activation=combined_activation / len(content_ids),
            salience=combined_salience,
            coalition=set(content_ids)
        )

        self.add_content(coalition)
        return coalition_id

    def get_stream_of_consciousness(self, length: int = 10) -> List[Dict[str, Any]]:
        """Get recent stream of consciousness (broadcast history)"""
        stream = []
        for content_id in self.broadcast_history[-length:]:
            if content_id in self.contents:
                content = self.contents[content_id]
                stream.append({
                    "id": content_id,
                    "type": content.content_type.value,
                    "data": content.data,
                    "timestamp": content.timestamp
                })
        return stream


# ============================================================================
# SELF-MODEL
# ============================================================================

@dataclass
class SelfRepresentation:
    """Representation of self in consciousness"""
    # Physical self
    body_schema: Dict[str, Any] = field(default_factory=dict)
    interoception: Dict[str, float] = field(default_factory=dict)  # Internal body states

    # Psychological self
    beliefs_about_self: Dict[str, float] = field(default_factory=dict)
    values: Dict[str, float] = field(default_factory=dict)
    goals: List[str] = field(default_factory=list)
    personality: Dict[str, float] = field(default_factory=dict)

    # Narrative self
    autobiographical_memories: List[str] = field(default_factory=list)
    life_story: str = ""
    future_projections: List[str] = field(default_factory=list)

    # Social self
    social_roles: List[str] = field(default_factory=list)
    reputation_model: Dict[str, float] = field(default_factory=dict)


class SelfModel:
    """
    Self-modeling system for self-awareness.
    Implements higher-order representations of self.
    """

    def __init__(self):
        self.representation = SelfRepresentation()
        self.meta_awareness: float = 0.5  # Awareness of own awareness
        self.self_continuity: float = 1.0  # Sense of continuous self
        self.agency_sense: float = 1.0  # Sense of being the agent

        # Self-monitoring
        self.current_mental_state: Dict[str, Any] = {}
        self.predicted_states: List[Dict[str, Any]] = []
        self.prediction_errors: List[float] = []

    def update_mental_state(self, state: Dict[str, Any]):
        """Update current mental state representation"""
        # Check prediction error
        if self.predicted_states:
            last_prediction = self.predicted_states[-1]
            error = self._calculate_prediction_error(last_prediction, state)
            self.prediction_errors.append(error)

            # High prediction error = surprising = affects agency sense
            if error > 0.5:
                self.agency_sense = max(0, self.agency_sense - 0.1)
            else:
                self.agency_sense = min(1, self.agency_sense + 0.02)

        self.current_mental_state = state

    def predict_next_state(self, action: str = None) -> Dict[str, Any]:
        """Predict next mental state"""
        prediction = dict(self.current_mental_state)

        # Simple prediction: small changes
        for key in prediction:
            if isinstance(prediction[key], (int, float)):
                prediction[key] += random.gauss(0, 0.1)

        if action:
            prediction["last_action"] = action

        self.predicted_states.append(prediction)
        return prediction

    def _calculate_prediction_error(self, predicted: Dict[str, Any],
                                   actual: Dict[str, Any]) -> float:
        """Calculate prediction error between states"""
        if not predicted or not actual:
            return 0.5

        errors = []
        for key in predicted:
            if key in actual:
                if isinstance(predicted[key], (int, float)) and isinstance(actual[key], (int, float)):
                    errors.append(abs(predicted[key] - actual[key]))

        return sum(errors) / len(errors) if errors else 0.5

    def introspect(self) -> Dict[str, Any]:
        """Introspect on current self-state"""
        return {
            "current_state": self.current_mental_state,
            "meta_awareness": self.meta_awareness,
            "agency_sense": self.agency_sense,
            "self_continuity": self.self_continuity,
            "recent_prediction_errors": self.prediction_errors[-10:],
            "representation": {
                "values": self.representation.values,
                "goals": self.representation.goals,
                "roles": self.representation.social_roles
            }
        }

    def reflect_on_experience(self, experience: Dict[str, Any]) -> str:
        """Generate reflection on an experience"""
        valence = experience.get("valence", 0)
        intensity = experience.get("intensity", 0.5)

        if valence > 0.5:
            reflection = f"This experience was positive (valence: {valence:.2f})"
        elif valence < -0.5:
            reflection = f"This experience was negative (valence: {valence:.2f})"
        else:
            reflection = f"This experience was neutral (valence: {valence:.2f})"

        if intensity > 0.7:
            reflection += ". It was quite intense."

        return reflection


# ============================================================================
# ATTENTION SYSTEM
# ============================================================================

class AttentionType(Enum):
    """Types of attention"""
    EXOGENOUS = "exogenous"  # Stimulus-driven
    ENDOGENOUS = "endogenous"  # Goal-driven
    EXECUTIVE = "executive"  # Control-based


@dataclass
class AttentionFocus:
    """Current focus of attention"""
    target: str
    attention_type: AttentionType
    intensity: float = 0.5
    duration: int = 0  # Time steps focused
    capacity_used: float = 0.0


class AttentionSystem:
    """
    Attention system controlling what enters consciousness.
    """

    def __init__(self, capacity: float = 1.0):
        self.capacity = capacity
        self.current_foci: List[AttentionFocus] = []
        self.saliency_map: Dict[str, float] = {}
        self.priority_queue: List[Tuple[float, str]] = []

        # Attentional biases
        self.novelty_bias: float = 0.3
        self.threat_bias: float = 0.5
        self.goal_relevance_bias: float = 0.4

    def update_saliency(self, target: str, saliency: float,
                       is_novel: bool = False, is_threat: bool = False,
                       goal_relevant: bool = False):
        """Update saliency of a target"""
        effective_saliency = saliency

        if is_novel:
            effective_saliency += self.novelty_bias
        if is_threat:
            effective_saliency += self.threat_bias
        if goal_relevant:
            effective_saliency += self.goal_relevance_bias

        self.saliency_map[target] = min(1.0, effective_saliency)
        heapq.heappush(self.priority_queue, (-effective_saliency, target))

    def allocate_attention(self) -> List[str]:
        """Allocate attention based on saliency and capacity"""
        allocated = []
        remaining_capacity = self.capacity
        self.current_foci = []

        while remaining_capacity > 0 and self.priority_queue:
            neg_saliency, target = heapq.heappop(self.priority_queue)
            saliency = -neg_saliency

            # Check if we have capacity
            cost = saliency * 0.5  # Higher saliency = more attention needed
            if cost <= remaining_capacity:
                focus = AttentionFocus(
                    target=target,
                    attention_type=AttentionType.EXOGENOUS,
                    intensity=saliency,
                    capacity_used=cost
                )
                self.current_foci.append(focus)
                allocated.append(target)
                remaining_capacity -= cost

        return allocated

    def voluntary_shift(self, target: str, intensity: float = 0.7):
        """Voluntarily shift attention"""
        focus = AttentionFocus(
            target=target,
            attention_type=AttentionType.ENDOGENOUS,
            intensity=intensity,
            capacity_used=intensity * 0.6
        )

        # Remove excess foci if over capacity
        while sum(f.capacity_used for f in self.current_foci) + focus.capacity_used > self.capacity:
            if self.current_foci:
                self.current_foci.pop()
            else:
                break

        self.current_foci.append(focus)

    def sustain_attention(self):
        """Sustain current attention (increases duration)"""
        for focus in self.current_foci:
            focus.duration += 1
            # Attention naturally decays
            focus.intensity *= 0.98

    def get_attention_state(self) -> Dict[str, Any]:
        """Get current attention state"""
        return {
            "foci": [
                {
                    "target": f.target,
                    "type": f.attention_type.value,
                    "intensity": f.intensity,
                    "duration": f.duration
                }
                for f in self.current_foci
            ],
            "capacity_used": sum(f.capacity_used for f in self.current_foci),
            "remaining_capacity": self.capacity - sum(f.capacity_used for f in self.current_foci)
        }


# ============================================================================
# INTEGRATED CONSCIOUSNESS SYSTEM
# ============================================================================

class ConsciousnessSystem:
    """
    Integrated consciousness simulation combining all components.
    """

    def __init__(self, agent_id: str):
        self.agent_id = agent_id

        # Core systems
        self.global_workspace = GlobalWorkspace()
        self.phi_calculator = IntegratedInformationCalculator()
        self.self_model = SelfModel()
        self.attention = AttentionSystem()

        # Phenomenal field
        self.phenomenal_field = PhenomenalField()

        # Stream of consciousness
        self.consciousness_stream: List[Dict[str, Any]] = []

        # Consciousness state
        self.wakefulness: float = 1.0  # 0 = unconscious, 1 = fully awake
        self.lucidity: float = 0.5  # Clarity of consciousness
        self.integration: float = 0.5  # How unified experience is

    def perceive(self, stimulus: Dict[str, Any]) -> Optional[str]:
        """Process a perception into consciousness"""
        # Create quale
        quale = Quale(
            id=f"quale_{len(self.phenomenal_field.qualia)}",
            quale_type=QualiaType.SENSORY,
            content=stimulus,
            intensity=stimulus.get("intensity", 0.5),
            valence=stimulus.get("valence", 0.0)
        )

        # Add to phenomenal field
        attended = stimulus.get("salient", False)
        self.phenomenal_field.add_quale(quale, attended)

        # Create workspace content
        content = WorkspaceContent(
            id=f"percept_{quale.id}",
            content_type=WorkspaceContentType.PERCEPT,
            data=stimulus,
            salience=stimulus.get("salience", 0.5),
            relevance=stimulus.get("relevance", 0.5)
        )
        self.global_workspace.add_content(content)

        # Update attention
        self.attention.update_saliency(
            content.id,
            content.salience,
            is_novel=stimulus.get("novel", False),
            is_threat=stimulus.get("threat", False)
        )

        # Add to phi calculation
        info_state = InformationState(
            id=content.id,
            state=1 if content.activation > 0.5 else 0
        )
        self.phi_calculator.add_element(info_state)

        return quale.id

    def think(self, thought: Dict[str, Any]) -> Optional[str]:
        """Generate a thought in consciousness"""
        # Create thought quale
        quale = Quale(
            id=f"thought_quale_{len(self.phenomenal_field.qualia)}",
            quale_type=QualiaType.COGNITIVE,
            content=thought,
            intensity=thought.get("intensity", 0.5)
        )
        self.phenomenal_field.add_quale(quale, attended=True)

        # Create workspace content
        content = WorkspaceContent(
            id=f"thought_{quale.id}",
            content_type=WorkspaceContentType.THOUGHT,
            data=thought,
            activation=0.6,  # Thoughts start with moderate activation
            relevance=thought.get("relevance", 0.6)
        )
        self.global_workspace.add_content(content)

        return quale.id

    def feel(self, emotion: Dict[str, Any]) -> Optional[str]:
        """Experience an emotion"""
        quale = Quale(
            id=f"emotion_quale_{len(self.phenomenal_field.qualia)}",
            quale_type=QualiaType.EMOTIONAL,
            content=emotion,
            intensity=emotion.get("intensity", 0.5),
            valence=emotion.get("valence", 0.0),
            arousal=emotion.get("arousal", 0.5)
        )
        self.phenomenal_field.add_quale(quale)

        content = WorkspaceContent(
            id=f"emotion_{quale.id}",
            content_type=WorkspaceContentType.EMOTION,
            data=emotion,
            salience=emotion.get("intensity", 0.5) * 0.8,  # Emotions are salient
            activation=emotion.get("intensity", 0.5)
        )
        self.global_workspace.add_content(content)

        return quale.id

    def conscious_cycle(self) -> Dict[str, Any]:
        """Run one cycle of conscious processing"""
        # Attention allocation
        attended = self.attention.allocate_attention()

        # Boost attended contents
        for target in attended:
            if target in self.global_workspace.contents:
                self.global_workspace.contents[target].boost(0.2)

        # Global workspace competition
        broadcast = self.global_workspace.competition_cycle()

        # Update self-model
        if broadcast:
            content = self.global_workspace.contents.get(broadcast)
            if content:
                self.self_model.update_mental_state(content.data)

        # Calculate phi
        phi = self.phi_calculator.calculate_phi()
        self.integration = phi

        # Update phenomenal field unity
        self.phenomenal_field.unity = self.integration

        # Sustain attention
        self.attention.sustain_attention()

        # Record in stream
        cycle_record = {
            "timestamp": datetime.now(),
            "broadcast": broadcast,
            "phi": phi,
            "attention": self.attention.get_attention_state(),
            "wakefulness": self.wakefulness,
            "field_size": len(self.phenomenal_field.qualia)
        }
        self.consciousness_stream.append(cycle_record)

        if len(self.consciousness_stream) > 1000:
            self.consciousness_stream.pop(0)

        return cycle_record

    def introspect(self) -> Dict[str, Any]:
        """Deep introspection on current conscious state"""
        return {
            "agent_id": self.agent_id,
            "wakefulness": self.wakefulness,
            "lucidity": self.lucidity,
            "integration": self.integration,
            "phi": self.phi_calculator.calculate_phi(),
            "consciousness_level": self.phi_calculator.get_consciousness_level(),
            "phenomenal_field": {
                "qualia_count": len(self.phenomenal_field.qualia),
                "focus": self.phenomenal_field.focus,
                "unity": self.phenomenal_field.unity,
                "total_intensity": self.phenomenal_field.get_total_intensity(),
                "emotional_valence": self.phenomenal_field.get_emotional_valence()
            },
            "attention": self.attention.get_attention_state(),
            "self_model": self.self_model.introspect(),
            "stream_length": len(self.consciousness_stream)
        }

    def get_what_its_like(self) -> str:
        """Attempt to verbalize current phenomenal experience"""
        field = self.phenomenal_field

        description_parts = []

        # Describe focus
        if field.focus and field.focus in field.qualia:
            focus_quale = field.qualia[field.focus]
            description_parts.append(
                f"Focused on: {focus_quale.content} (intensity: {focus_quale.intensity:.2f})"
            )

        # Describe emotional state
        emotional_valence = field.get_emotional_valence()
        if emotional_valence > 0.3:
            description_parts.append("Experiencing positive affect")
        elif emotional_valence < -0.3:
            description_parts.append("Experiencing negative affect")

        # Describe integration
        if self.integration > 0.7:
            description_parts.append("Experience feels unified and coherent")
        elif self.integration < 0.3:
            description_parts.append("Experience feels fragmented")

        # Describe wakefulness
        if self.wakefulness > 0.8:
            description_parts.append("Fully alert and aware")
        elif self.wakefulness < 0.3:
            description_parts.append("Consciousness is dim")

        return "; ".join(description_parts) if description_parts else "Experience is minimal"


# Convenience functions
def create_consciousness_system(agent_id: str) -> ConsciousnessSystem:
    """Create a consciousness system"""
    return ConsciousnessSystem(agent_id)


def demo_consciousness():
    """Demonstrate consciousness system"""
    print("=== Consciousness Demo ===")

    cs = create_consciousness_system("conscious_agent")

    # Register a module
    def perception_module(content):
        print(f"  [Perception module received: {content.content_type.value}]")

    cs.global_workspace.register_module("perception", perception_module)

    # Generate some experiences
    print("\n1. Perceiving stimuli...")
    cs.perceive({
        "type": "visual",
        "content": "red apple",
        "intensity": 0.7,
        "salience": 0.8,
        "novel": True
    })

    print("\n2. Thinking...")
    cs.think({
        "content": "I should eat the apple",
        "relevance": 0.9
    })

    print("\n3. Feeling...")
    cs.feel({
        "emotion": "desire",
        "intensity": 0.6,
        "valence": 0.4,
        "arousal": 0.5
    })

    # Run conscious cycles
    print("\n4. Running conscious cycles...")
    for i in range(5):
        result = cs.conscious_cycle()
        print(f"  Cycle {i+1}: broadcast={result['broadcast']}, phi={result['phi']:.3f}")

    # Introspect
    print("\n5. Introspection:")
    intro = cs.introspect()
    print(f"  Consciousness level: {intro['consciousness_level']}")
    print(f"  Phi: {intro['phi']:.3f}")
    print(f"  Phenomenal field size: {intro['phenomenal_field']['qualia_count']}")
    print(f"  Emotional valence: {intro['phenomenal_field']['emotional_valence']:.2f}")

    print("\n6. What it's like:")
    print(f"  {cs.get_what_its_like()}")

    return cs


if __name__ == "__main__":
    demo_consciousness()
